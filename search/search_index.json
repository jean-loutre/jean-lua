{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Jean Lua An object-oriented lua toolkit library. For a complete reference of classes included in this library, check usage section","title":"Home"},{"location":"#welcome-to-jean-lua","text":"An object-oriented lua toolkit library. For a complete reference of classes included in this library, check usage section","title":"Welcome to Jean Lua"},{"location":"api/collection/","text":"","title":"Api Reference"},{"location":"api/context/","text":"","title":"Context"},{"location":"api/iterator/","text":"jlua.iterator Iterator, with map / filter functions and the like. Methods init(iterator, invariant, control) Parameter Type Description Default iterator * fn(any,any?):any? The iterator function. invariant * any? Invariant state passed to the iterator. control * any? Initial control variable passed to the Can be initialized with a statefull iterator closure, or a stateless iterator iterator. In the later case, invariant and control are the states needed by the stateless iterator. For example, you can call : Iterator ( ipairs ({ \"some\" , \"list\" })) __call() Return the next element of the iterator. Parameter Type Description Default all(predicate) Return true if all elements in the iterator matches the given predicate. Parameter Type Description Default predicate * any any(predicate) Return true if any element in the iterator matches the given predicate. Parameter Type Description Default predicate * any chain(iterable, ...) Chain this iterator with elements of given iterable. Parameter Type Description Default iterable * any ... * any contains(item) Return true if any element in the iterator equals the given element Parameter Type Description Default item * any The item to check in the iterator count(predicate) Count number of element matching the given predicate. Parameter Type Description Default predicate * any filter(predicate) Return an iterator yielding elements matching the given predicate. Parameter Type Description Default predicate * any first(predicate) Return the first element in the iterator matching the given predicate. Parameter Type Description Default predicate * any map(mapper) Return a new iterator yielding results of applying a function to all items. Parameter Type Description Default mapper * any flatten() Returns elements of the nested iterator of an iterator of iterators. Parameter Type Description Default reduce(func, init) Reduce the iterator. Parameter Type Description Default func * any init * any skip(count) Skip the first count elements of an iterator. Parameter Type Description Default count * any take(count) Return the first elements of an iterator. Parameter Type Description Default count * any","title":"jlua.iterator"},{"location":"api/iterator/#jluaiterator","text":"Iterator, with map / filter functions and the like.","title":"jlua.iterator"},{"location":"api/iterator/#methods","text":"","title":"Methods"},{"location":"api/iterator/#inititerator-invariant-control","text":"Parameter Type Description Default iterator * fn(any,any?):any? The iterator function. invariant * any? Invariant state passed to the iterator. control * any? Initial control variable passed to the Can be initialized with a statefull iterator closure, or a stateless iterator iterator. In the later case, invariant and control are the states needed by the stateless iterator. For example, you can call : Iterator ( ipairs ({ \"some\" , \"list\" }))","title":"init(iterator, invariant, control)"},{"location":"api/iterator/#__call","text":"Return the next element of the iterator. Parameter Type Description Default","title":"__call()"},{"location":"api/iterator/#allpredicate","text":"Return true if all elements in the iterator matches the given predicate. Parameter Type Description Default predicate * any","title":"all(predicate)"},{"location":"api/iterator/#anypredicate","text":"Return true if any element in the iterator matches the given predicate. Parameter Type Description Default predicate * any","title":"any(predicate)"},{"location":"api/iterator/#chainiterable","text":"Chain this iterator with elements of given iterable. Parameter Type Description Default iterable * any ... * any","title":"chain(iterable, ...)"},{"location":"api/iterator/#containsitem","text":"Return true if any element in the iterator equals the given element Parameter Type Description Default item * any The item to check in the iterator","title":"contains(item)"},{"location":"api/iterator/#countpredicate","text":"Count number of element matching the given predicate. Parameter Type Description Default predicate * any","title":"count(predicate)"},{"location":"api/iterator/#filterpredicate","text":"Return an iterator yielding elements matching the given predicate. Parameter Type Description Default predicate * any","title":"filter(predicate)"},{"location":"api/iterator/#firstpredicate","text":"Return the first element in the iterator matching the given predicate. Parameter Type Description Default predicate * any","title":"first(predicate)"},{"location":"api/iterator/#mapmapper","text":"Return a new iterator yielding results of applying a function to all items. Parameter Type Description Default mapper * any","title":"map(mapper)"},{"location":"api/iterator/#flatten","text":"Returns elements of the nested iterator of an iterator of iterators. Parameter Type Description Default","title":"flatten()"},{"location":"api/iterator/#reducefunc-init","text":"Reduce the iterator. Parameter Type Description Default func * any init * any","title":"reduce(func, init)"},{"location":"api/iterator/#skipcount","text":"Skip the first count elements of an iterator. Parameter Type Description Default count * any","title":"skip(count)"},{"location":"api/iterator/#takecount","text":"Return the first elements of an iterator. Parameter Type Description Default count * any","title":"take(count)"},{"location":"api/list/","text":"","title":"List"},{"location":"api/map/","text":"","title":"Map"},{"location":"api/object/","text":"","title":"Object"},{"location":"api/path/","text":"","title":"Path"},{"location":"api/string/","text":"","title":"String"},{"location":"api/type/","text":"","title":"Type"},{"location":"api/test/call/","text":"","title":"Test"},{"location":"api/test/mock/","text":"","title":"Mock"},{"location":"usage/_index/","text":"Usage Here is the documentation of the jean-lua API.","title":"Usage"},{"location":"usage/_index/#usage","text":"Here is the documentation of the jean-lua API.","title":"Usage"},{"location":"usage/functional/","text":"Functional Functional programming involves iterators and function objects.","title":"Functional"},{"location":"usage/functional/#functional","text":"Functional programming involves iterators and function objects.","title":"Functional"},{"location":"usage/object/","text":"Object The jlua.object module contains definition of an Object class, that can be extended to create new classes. It supports single inheritance, methods, properties with getters and setters and metamethod overriding, including __index and __newindex. Defining a new class A new class can be created by extending from another one. Derived class will inherit the methods, metamethods and properties of it's parent. If your class has no base class, extend the Object class. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () local SpaceOtter = Otter : extend () Constructors Objects are constructed by calling the class. You can give arguments to the constructor, they will be forwarded to the init method of the class, if it's defined. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init ( name ) print ( \"My name is \" .. name ) end local peter = Otter ( \"Peter\" ) -- -> \"My name is Peter\" Warning If you override a base class init method, don't forget to call the parent init method by calling self:super(\"init\", ...) . Methods Method Definition Methods can be defined either by adding them on the class metatable before calling the extend() method, or afterwards, by defining them on the class, like you do on regular lua tables : local Object = require ( \"jlua.object\" ) local Otter = Object : extend ({ name = function () return \"Peter\" end }) function Otter : last_name () return \"Otterson\" end Warning Defining twice the same method will assert. This is done to prevent unwanted method overwrites. If you really need to overwrite a method, you can do it by using rawset like this: rawset(Otter._definition._metatable, \"last_name\", function() [...] end) Calling Parent Methods To call a parent method in a child class, use the super() method defined on classes instances, with the method name as the first argument, arguments to forward to the parent method next : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : throw ( distance ) return \"throwing otter at \" .. distance .. \"m\" end local SpaceOtter = Otter : extend () local SpaceOtter : throw ( distance ) self : super ( \"throw\" , distance + 100 ) end local peter = SpaceOtter () peter : throw_at ( 33 ) -- -> Throwing otter at 133m Properties Properties are defined using the \"properties\" field of classes, accessing the wanted property on it and defining a get or a set method : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init () self . _age = 10 end function Otter . properties . age : get () -- Notice the colon before get() return self . _age end function Otter . properties . age : set ( value ) -- Notice the colon before set() self . _age = value end local peter = Otter () print ( peter . age ) -- 10 peter . age = 40 print ( peter . age ) -- 40 You can define properties with only a getter, or only a setter. You can define a property with no getter nor setter, but in this case it will only be defined in your head and will have no effect on the running program. Warning Setting a property with no setter defined, or getting a property with no getter will raise an error at runtime. There is no default behavior for getters / setters once one of them is defined. Warning Redefining a getter or a setter that was already defined on a property will raise an error. Same as for methods, this was made to prevent erroneous method overwriting.","title":"Object"},{"location":"usage/object/#object","text":"The jlua.object module contains definition of an Object class, that can be extended to create new classes. It supports single inheritance, methods, properties with getters and setters and metamethod overriding, including __index and __newindex.","title":"Object"},{"location":"usage/object/#defining-a-new-class","text":"A new class can be created by extending from another one. Derived class will inherit the methods, metamethods and properties of it's parent. If your class has no base class, extend the Object class. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () local SpaceOtter = Otter : extend ()","title":"Defining a new class"},{"location":"usage/object/#constructors","text":"Objects are constructed by calling the class. You can give arguments to the constructor, they will be forwarded to the init method of the class, if it's defined. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init ( name ) print ( \"My name is \" .. name ) end local peter = Otter ( \"Peter\" ) -- -> \"My name is Peter\" Warning If you override a base class init method, don't forget to call the parent init method by calling self:super(\"init\", ...) .","title":"Constructors"},{"location":"usage/object/#methods","text":"","title":"Methods"},{"location":"usage/object/#method-definition","text":"Methods can be defined either by adding them on the class metatable before calling the extend() method, or afterwards, by defining them on the class, like you do on regular lua tables : local Object = require ( \"jlua.object\" ) local Otter = Object : extend ({ name = function () return \"Peter\" end }) function Otter : last_name () return \"Otterson\" end Warning Defining twice the same method will assert. This is done to prevent unwanted method overwrites. If you really need to overwrite a method, you can do it by using rawset like this: rawset(Otter._definition._metatable, \"last_name\", function() [...] end)","title":"Method Definition"},{"location":"usage/object/#calling-parent-methods","text":"To call a parent method in a child class, use the super() method defined on classes instances, with the method name as the first argument, arguments to forward to the parent method next : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : throw ( distance ) return \"throwing otter at \" .. distance .. \"m\" end local SpaceOtter = Otter : extend () local SpaceOtter : throw ( distance ) self : super ( \"throw\" , distance + 100 ) end local peter = SpaceOtter () peter : throw_at ( 33 ) -- -> Throwing otter at 133m","title":"Calling Parent Methods"},{"location":"usage/object/#properties","text":"Properties are defined using the \"properties\" field of classes, accessing the wanted property on it and defining a get or a set method : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init () self . _age = 10 end function Otter . properties . age : get () -- Notice the colon before get() return self . _age end function Otter . properties . age : set ( value ) -- Notice the colon before set() self . _age = value end local peter = Otter () print ( peter . age ) -- 10 peter . age = 40 print ( peter . age ) -- 40 You can define properties with only a getter, or only a setter. You can define a property with no getter nor setter, but in this case it will only be defined in your head and will have no effect on the running program. Warning Setting a property with no setter defined, or getting a property with no getter will raise an error at runtime. There is no default behavior for getters / setters once one of them is defined. Warning Redefining a getter or a setter that was already defined on a property will raise an error. Same as for methods, this was made to prevent erroneous method overwriting.","title":"Properties"}]}