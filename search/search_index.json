{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Jean Lua \u00b6 An object-oriented lua toolkit library. For a complete reference of classes included in this library, check usage section","title":"Home"},{"location":"#welcome-to-jean-lua","text":"An object-oriented lua toolkit library. For a complete reference of classes included in this library, check usage section","title":"Welcome to Jean Lua"},{"location":"api/collection/","text":"unknown \u00b6 Classes \u00b6 Collection \u00b6 Methods \u00b6 iter() \u00b6 Signature Get an iterator over collection items function Collection : iter () -> nil Parameter Type Description Default concat() \u00b6 Signature Concatenate the values of this collection function Collection : concat ( delimiter : any ) -> nil Parameter Type Description Default delimiter * any","title":"Api Reference"},{"location":"api/collection/#unknown","text":"","title":"unknown"},{"location":"api/collection/#classes","text":"","title":"Classes"},{"location":"api/collection/#collection","text":"","title":"Collection"},{"location":"api/collection/#methods","text":"","title":"Methods"},{"location":"api/collection/#iter","text":"Signature Get an iterator over collection items function Collection : iter () -> nil Parameter Type Description Default","title":"iter()"},{"location":"api/collection/#concat","text":"Signature Concatenate the values of this collection function Collection : concat ( delimiter : any ) -> nil Parameter Type Description Default delimiter * any","title":"concat()"},{"location":"api/context/","text":"unknown \u00b6","title":"unknown"},{"location":"api/context/#unknown","text":"","title":"unknown"},{"location":"api/iterator/","text":"jlua.iterator \u00b6 Iterator, with map / filter functions and the like. Methods \u00b6 init() \u00b6 Signature function jlua . iterator : init ( iterator : func (: any ,: any ? ): any ? , invariant : any ? , control : any ? ) -> nil Parameter Type Description Default iterator * func(:any,:any?):any? The iterator function. invariant * any? Invariant state passed to the iterator. control * any? Initial control variable passed to the Notes Can be initialized with a statefull iterator closure, or a stateless iterator iterator. In the later case, invariant and control are the states needed by the stateless iterator. For example, you can call : Iterator ( ipairs ({ \"some\" , \"list\" })) __call() \u00b6 Signature Return the next element of the iterator. function jlua . iterator : __call () -> nil Parameter Type Description Default all() \u00b6 Signature Return true if all elements in the iterator matches the given predicate. function jlua . iterator : all ( predicate : any ) -> nil Parameter Type Description Default predicate * any any() \u00b6 Signature Return true if any element in the iterator matches the given predicate. function jlua . iterator : any ( predicate : any ) -> nil Parameter Type Description Default predicate * any chain() \u00b6 Signature Chain this iterator with elements of given iterable. function jlua . iterator : chain ( iterable : any , ...: any ) -> nil Parameter Type Description Default iterable * any ... * any contains() \u00b6 Signature Return true if any element in the iterator equals the given element function jlua . iterator : contains ( item : any ) -> string Parameter Type Description Default item * any The item to check in the iterator Returns Description string True if an element equals the given item, false otherwise. count() \u00b6 Signature Count number of element matching the given predicate. function jlua . iterator : count ( predicate : any ) -> nil Parameter Type Description Default predicate * any filter() \u00b6 Signature Return an iterator yielding elements matching the given predicate. function jlua . iterator : filter ( predicate : any ) -> nil Parameter Type Description Default predicate * any first() \u00b6 Signature Return the first element in the iterator matching the given predicate. function jlua . iterator : first ( predicate : any ) -> nil Parameter Type Description Default predicate * any map() \u00b6 Signature Return a new iterator yielding results of applying a function to all items. function jlua . iterator : map ( mapper : any ) -> nil Parameter Type Description Default mapper * any flatten() \u00b6 Signature Returns elements of the nested iterator of an iterator of iterators. function jlua . iterator : flatten () -> nil Parameter Type Description Default reduce() \u00b6 Signature Reduce the iterator. function jlua . iterator : reduce ( func : any , init : any ) -> nil Parameter Type Description Default func * any init * any skip() \u00b6 Signature Skip the first count elements of an iterator. function jlua . iterator : skip ( count : any ) -> nil Parameter Type Description Default count * any take() \u00b6 Signature Return the first elements of an iterator. function jlua . iterator : take ( count : any ) -> nil Parameter Type Description Default count * any","title":"jlua.iterator"},{"location":"api/iterator/#jluaiterator","text":"Iterator, with map / filter functions and the like.","title":"jlua.iterator"},{"location":"api/iterator/#methods","text":"","title":"Methods"},{"location":"api/iterator/#init","text":"Signature function jlua . iterator : init ( iterator : func (: any ,: any ? ): any ? , invariant : any ? , control : any ? ) -> nil Parameter Type Description Default iterator * func(:any,:any?):any? The iterator function. invariant * any? Invariant state passed to the iterator. control * any? Initial control variable passed to the Notes Can be initialized with a statefull iterator closure, or a stateless iterator iterator. In the later case, invariant and control are the states needed by the stateless iterator. For example, you can call : Iterator ( ipairs ({ \"some\" , \"list\" }))","title":"init()"},{"location":"api/iterator/#__call","text":"Signature Return the next element of the iterator. function jlua . iterator : __call () -> nil Parameter Type Description Default","title":"__call()"},{"location":"api/iterator/#all","text":"Signature Return true if all elements in the iterator matches the given predicate. function jlua . iterator : all ( predicate : any ) -> nil Parameter Type Description Default predicate * any","title":"all()"},{"location":"api/iterator/#any","text":"Signature Return true if any element in the iterator matches the given predicate. function jlua . iterator : any ( predicate : any ) -> nil Parameter Type Description Default predicate * any","title":"any()"},{"location":"api/iterator/#chain","text":"Signature Chain this iterator with elements of given iterable. function jlua . iterator : chain ( iterable : any , ...: any ) -> nil Parameter Type Description Default iterable * any ... * any","title":"chain()"},{"location":"api/iterator/#contains","text":"Signature Return true if any element in the iterator equals the given element function jlua . iterator : contains ( item : any ) -> string Parameter Type Description Default item * any The item to check in the iterator Returns Description string True if an element equals the given item, false otherwise.","title":"contains()"},{"location":"api/iterator/#count","text":"Signature Count number of element matching the given predicate. function jlua . iterator : count ( predicate : any ) -> nil Parameter Type Description Default predicate * any","title":"count()"},{"location":"api/iterator/#filter","text":"Signature Return an iterator yielding elements matching the given predicate. function jlua . iterator : filter ( predicate : any ) -> nil Parameter Type Description Default predicate * any","title":"filter()"},{"location":"api/iterator/#first","text":"Signature Return the first element in the iterator matching the given predicate. function jlua . iterator : first ( predicate : any ) -> nil Parameter Type Description Default predicate * any","title":"first()"},{"location":"api/iterator/#map","text":"Signature Return a new iterator yielding results of applying a function to all items. function jlua . iterator : map ( mapper : any ) -> nil Parameter Type Description Default mapper * any","title":"map()"},{"location":"api/iterator/#flatten","text":"Signature Returns elements of the nested iterator of an iterator of iterators. function jlua . iterator : flatten () -> nil Parameter Type Description Default","title":"flatten()"},{"location":"api/iterator/#reduce","text":"Signature Reduce the iterator. function jlua . iterator : reduce ( func : any , init : any ) -> nil Parameter Type Description Default func * any init * any","title":"reduce()"},{"location":"api/iterator/#skip","text":"Signature Skip the first count elements of an iterator. function jlua . iterator : skip ( count : any ) -> nil Parameter Type Description Default count * any","title":"skip()"},{"location":"api/iterator/#take","text":"Signature Return the first elements of an iterator. function jlua . iterator : take ( count : any ) -> nil Parameter Type Description Default count * any","title":"take()"},{"location":"api/list/","text":"jlua.List \u00b6 A list of items, with random access. Classes \u00b6 List \u00b6 Methods \u00b6 init() \u00b6 Signature Initialize a list from a table function List : init (...: A ) -> nil Parameter Type Description Default ... * A table, or anything that can be passed to Iterator.iter(...) push() \u00b6 Signature Add an item into the list function List : push ( item : any ) -> nil Parameter Type Description Default item * any pop() \u00b6 Signature Remove the item at the end of the list function List : pop () -> nil Parameter Type Description Default remove() \u00b6 Signature Remove the first occurence of an item from the list function List : remove ( item : any ) -> nil Parameter Type Description Default item * any sort() \u00b6 Signature Sort the list function List : sort ( predicate : any ) -> nil Parameter Type Description Default predicate * any slice() \u00b6 Signature Return a jlua.iterator over a slice of this list function List : slice ( start : any , end_ : any ) -> nil Parameter Type Description Default start * any end_ * any reverse() \u00b6 Signature Return a jlua.iterator on element of the list, in the reverse order function List : reverse () -> nil Parameter Type Description Default __iter() \u00b6 Signature function List : __iter () -> nil Parameter Type Description Default Iterator \u00b6 Methods \u00b6 to_list() \u00b6 Signature Create a list containing all elements of the iterator. function Iterator : to_list () -> nil Parameter Type Description Default","title":"jlua.List"},{"location":"api/list/#jlualist","text":"A list of items, with random access.","title":"jlua.List"},{"location":"api/list/#classes","text":"","title":"Classes"},{"location":"api/list/#list","text":"","title":"List"},{"location":"api/list/#methods","text":"","title":"Methods"},{"location":"api/list/#init","text":"Signature Initialize a list from a table function List : init (...: A ) -> nil Parameter Type Description Default ... * A table, or anything that can be passed to Iterator.iter(...)","title":"init()"},{"location":"api/list/#push","text":"Signature Add an item into the list function List : push ( item : any ) -> nil Parameter Type Description Default item * any","title":"push()"},{"location":"api/list/#pop","text":"Signature Remove the item at the end of the list function List : pop () -> nil Parameter Type Description Default","title":"pop()"},{"location":"api/list/#remove","text":"Signature Remove the first occurence of an item from the list function List : remove ( item : any ) -> nil Parameter Type Description Default item * any","title":"remove()"},{"location":"api/list/#sort","text":"Signature Sort the list function List : sort ( predicate : any ) -> nil Parameter Type Description Default predicate * any","title":"sort()"},{"location":"api/list/#slice","text":"Signature Return a jlua.iterator over a slice of this list function List : slice ( start : any , end_ : any ) -> nil Parameter Type Description Default start * any end_ * any","title":"slice()"},{"location":"api/list/#reverse","text":"Signature Return a jlua.iterator on element of the list, in the reverse order function List : reverse () -> nil Parameter Type Description Default","title":"reverse()"},{"location":"api/list/#__iter","text":"Signature function List : __iter () -> nil Parameter Type Description Default","title":"__iter()"},{"location":"api/list/#iterator","text":"","title":"Iterator"},{"location":"api/list/#methods_1","text":"","title":"Methods"},{"location":"api/list/#to_list","text":"Signature Create a list containing all elements of the iterator. function Iterator : to_list () -> nil Parameter Type Description Default","title":"to_list()"},{"location":"api/logging/","text":"jlua.logging \u00b6 Hierarchical logging facility. This module is heavily inspired from Python's logging facility. Enums \u00b6 LOG_LEVEL \u00b6 Logging level for messages & filters. Can be used to set the level of a message when calling log . Message emmited can then be filtered by using this enum. Member Description DEBUG Verbose diagnostics. INFO Important informations to show to the user. WARNING Handled errors. ERROR Recoverable errors. CRITICAL Failures. Methods \u00b6 get_logger() \u00b6 Signature Get a Logger instance. function get_logger ( name : string ) -> Logger Parameter Type Description Default name * string The name of the logger. Returns Description Logger Logger instance. Notes If a logger with the given name already exists, will return the same instance. Separate the level of hierarchy with dots. i.e if you create a logger named \"jean.jacques\", all messages logged to it will be forwarded to the logger named \"jean\". Classes \u00b6 Logger \u00b6 A logger, allowing to emit log message. To create a new logger, use get_logger , this class isn't meant to be contsructed directly. Methods \u00b6 add_handler() \u00b6 Signature Add a log handler to this logger. function Logger : add_handler ( -> : function ( LogRecord )) -> nil Parameter Type Description Default -> * function(LogRecord) nil The handler to add. Notes Add an handler to this logger. It will be called for every log record that is emitted by this logger or one of it's child, and that passes the log filters. If a handler is added multiple times, it will be called multiple times when a LogRecord is emitted. Usage logger = get_logger ( _REQUIRED_NAME ) local function print_log ( record ) print ( format ( record . format , record . args )) end logger : add_handler ( print_log ) remove_handler() \u00b6 Signature Remove a previously added handle of this logger. function Logger : remove_handler ( -> : function ( LogRecord )) -> nil Parameter Type Description Default -> * function(LogRecord) nil The handler to remove. Notes If the hanlder was added multiple times, remove only the first occurence. log() \u00b6 Signature Emmit a log message on this handler. function Logger : log ( log_level : LOG_LEVEL , fmt : string ) -> nil Parameter Type Description Default log_level * LOG_LEVEL The log level of the log entry. fmt * string The format string for the message Notes Create a LogRecord from the given arguments, emit the LogRecord on parents of this logger, and call the handlers registered on this logger if the record passes the filter. Usage logger = get_logger ( _REQUIRED_NAME ) ... logger : log ( LOG_LEVEL . ERROR , \"An error occured\" ) of the log entry . debug() \u00b6 Signature Emmit a debug log message on this logger. function Logger : debug ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.DEBUG. info() \u00b6 Signature Emmit an info log message on this logger. function Logger : info ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.INFO. warning() \u00b6 Signature Emmit a warning log message on this logger. function Logger : warning ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.WARNING. error() \u00b6 Signature Emmit an error log message on this logger. function Logger : error ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.ERROR. critical() \u00b6 Signature Emmit a critical log message on this logger. function Logger : critical ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.CRITICAL .","title":"jlua.logging"},{"location":"api/logging/#jlualogging","text":"Hierarchical logging facility. This module is heavily inspired from Python's logging facility.","title":"jlua.logging"},{"location":"api/logging/#enums","text":"","title":"Enums"},{"location":"api/logging/#log_level","text":"Logging level for messages & filters. Can be used to set the level of a message when calling log . Message emmited can then be filtered by using this enum. Member Description DEBUG Verbose diagnostics. INFO Important informations to show to the user. WARNING Handled errors. ERROR Recoverable errors. CRITICAL Failures.","title":"LOG_LEVEL"},{"location":"api/logging/#methods","text":"","title":"Methods"},{"location":"api/logging/#get_logger","text":"Signature Get a Logger instance. function get_logger ( name : string ) -> Logger Parameter Type Description Default name * string The name of the logger. Returns Description Logger Logger instance. Notes If a logger with the given name already exists, will return the same instance. Separate the level of hierarchy with dots. i.e if you create a logger named \"jean.jacques\", all messages logged to it will be forwarded to the logger named \"jean\".","title":"get_logger()"},{"location":"api/logging/#classes","text":"","title":"Classes"},{"location":"api/logging/#logger","text":"A logger, allowing to emit log message. To create a new logger, use get_logger , this class isn't meant to be contsructed directly.","title":"Logger"},{"location":"api/logging/#methods_1","text":"","title":"Methods"},{"location":"api/logging/#add_handler","text":"Signature Add a log handler to this logger. function Logger : add_handler ( -> : function ( LogRecord )) -> nil Parameter Type Description Default -> * function(LogRecord) nil The handler to add. Notes Add an handler to this logger. It will be called for every log record that is emitted by this logger or one of it's child, and that passes the log filters. If a handler is added multiple times, it will be called multiple times when a LogRecord is emitted. Usage logger = get_logger ( _REQUIRED_NAME ) local function print_log ( record ) print ( format ( record . format , record . args )) end logger : add_handler ( print_log )","title":"add_handler()"},{"location":"api/logging/#remove_handler","text":"Signature Remove a previously added handle of this logger. function Logger : remove_handler ( -> : function ( LogRecord )) -> nil Parameter Type Description Default -> * function(LogRecord) nil The handler to remove. Notes If the hanlder was added multiple times, remove only the first occurence.","title":"remove_handler()"},{"location":"api/logging/#log","text":"Signature Emmit a log message on this handler. function Logger : log ( log_level : LOG_LEVEL , fmt : string ) -> nil Parameter Type Description Default log_level * LOG_LEVEL The log level of the log entry. fmt * string The format string for the message Notes Create a LogRecord from the given arguments, emit the LogRecord on parents of this logger, and call the handlers registered on this logger if the record passes the filter. Usage logger = get_logger ( _REQUIRED_NAME ) ... logger : log ( LOG_LEVEL . ERROR , \"An error occured\" ) of the log entry .","title":"log()"},{"location":"api/logging/#debug","text":"Signature Emmit a debug log message on this logger. function Logger : debug ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.DEBUG.","title":"debug()"},{"location":"api/logging/#info","text":"Signature Emmit an info log message on this logger. function Logger : info ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.INFO.","title":"info()"},{"location":"api/logging/#warning","text":"Signature Emmit a warning log message on this logger. function Logger : warning ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.WARNING.","title":"warning()"},{"location":"api/logging/#error","text":"Signature Emmit an error log message on this logger. function Logger : error ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.ERROR.","title":"error()"},{"location":"api/logging/#critical","text":"Signature Emmit a critical log message on this logger. function Logger : critical ( string : fmt ) -> nil Parameter Type Description Default string * fmt The format string for the message of the log Notes Will forward call to log with level set to LOG_LEVEL.CRITICAL .","title":"critical()"},{"location":"api/map/","text":"unknown \u00b6 Classes \u00b6 jlua.Map \u00b6 Methods \u00b6 init() \u00b6 Signature Initialize a map from lua table function jlua . Map : init (...: any ) -> nil Parameter Type Description Default ... * any __iter() \u00b6 Signature Return a jlua.pair_iterator over the element of the collection function jlua . Map : __iter () -> nil Parameter Type Description Default deep_update() \u00b6 Signature Update values in this map with given values, recursively. function jlua . Map : deep_update (...: any ) -> nil Parameter Type Description Default ... * any merge() \u00b6 Signature Create a new map with values of self updated with values of given map. function jlua . Map : merge (...: any ) -> nil Parameter Type Description Default ... * any pop() \u00b6 Signature Get a value and removes it from the map. function jlua . Map : pop ( key : any , default_value : any ) -> nil Parameter Type Description Default key * any default_value * any to_raw() \u00b6 Signature Return a raw table containing the content of the map. function jlua . Map : to_raw () -> nil Parameter Type Description Default update() \u00b6 Signature Update values in this map with given values. function jlua . Map : update (...: any ) -> nil Parameter Type Description Default ... * any Iterator \u00b6 Methods \u00b6 to_map() \u00b6 Signature Return a map containing elements of this iterator function Iterator : to_map ( key_getter : any ) -> nil Parameter Type Description Default key_getter * any","title":"unknown"},{"location":"api/map/#unknown","text":"","title":"unknown"},{"location":"api/map/#classes","text":"","title":"Classes"},{"location":"api/map/#jluamap","text":"","title":"jlua.Map"},{"location":"api/map/#methods","text":"","title":"Methods"},{"location":"api/map/#init","text":"Signature Initialize a map from lua table function jlua . Map : init (...: any ) -> nil Parameter Type Description Default ... * any","title":"init()"},{"location":"api/map/#__iter","text":"Signature Return a jlua.pair_iterator over the element of the collection function jlua . Map : __iter () -> nil Parameter Type Description Default","title":"__iter()"},{"location":"api/map/#deep_update","text":"Signature Update values in this map with given values, recursively. function jlua . Map : deep_update (...: any ) -> nil Parameter Type Description Default ... * any","title":"deep_update()"},{"location":"api/map/#merge","text":"Signature Create a new map with values of self updated with values of given map. function jlua . Map : merge (...: any ) -> nil Parameter Type Description Default ... * any","title":"merge()"},{"location":"api/map/#pop","text":"Signature Get a value and removes it from the map. function jlua . Map : pop ( key : any , default_value : any ) -> nil Parameter Type Description Default key * any default_value * any","title":"pop()"},{"location":"api/map/#to_raw","text":"Signature Return a raw table containing the content of the map. function jlua . Map : to_raw () -> nil Parameter Type Description Default","title":"to_raw()"},{"location":"api/map/#update","text":"Signature Update values in this map with given values. function jlua . Map : update (...: any ) -> nil Parameter Type Description Default ... * any","title":"update()"},{"location":"api/map/#iterator","text":"","title":"Iterator"},{"location":"api/map/#methods_1","text":"","title":"Methods"},{"location":"api/map/#to_map","text":"Signature Return a map containing elements of this iterator function Iterator : to_map ( key_getter : any ) -> nil Parameter Type Description Default key_getter * any","title":"to_map()"},{"location":"api/object/","text":"unknown \u00b6 Classes \u00b6 jlua.Class \u00b6 Base class for class model Metatable for classes Methods \u00b6 __index() \u00b6 Signature function jlua . Class : __index ( key : any ) -> nil Parameter Type Description Default key * any __newindex() \u00b6 Signature function jlua . Class : __newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any __call() \u00b6 Signature Class \"constructor\", creating a new object. function jlua . Class : __call (...: any ) -> nil Parameter Type Description Default ... * any extend() \u00b6 Signature Create a new child class of this class. function jlua . Class : extend ( name : any ) -> nil Parameter Type Description Default name * any is_class_of() \u00b6 Signature Return true if the given object is an instance of this class. function jlua . Class : is_class_of ( object : any ) -> nil Parameter Type Description Default object * any wrap() \u00b6 Signature Create an instance of this class by setting it's metatable. function jlua . Class : wrap ( object : any ) -> nil Parameter Type Description Default object * any PropertyGuard \u00b6 Methods \u00b6 __newindex() \u00b6 Signature function PropertyGuard : __newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any PropertiesGuard \u00b6 Methods \u00b6 __index() \u00b6 Signature function PropertiesGuard : __index ( key : any ) -> nil Parameter Type Description Default key * any __newindex() \u00b6 Signature function PropertiesGuard : __newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any","title":"unknown"},{"location":"api/object/#unknown","text":"","title":"unknown"},{"location":"api/object/#classes","text":"","title":"Classes"},{"location":"api/object/#jluaclass","text":"Base class for class model Metatable for classes","title":"jlua.Class"},{"location":"api/object/#methods","text":"","title":"Methods"},{"location":"api/object/#__index","text":"Signature function jlua . Class : __index ( key : any ) -> nil Parameter Type Description Default key * any","title":"__index()"},{"location":"api/object/#__newindex","text":"Signature function jlua . Class : __newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any","title":"__newindex()"},{"location":"api/object/#__call","text":"Signature Class \"constructor\", creating a new object. function jlua . Class : __call (...: any ) -> nil Parameter Type Description Default ... * any","title":"__call()"},{"location":"api/object/#extend","text":"Signature Create a new child class of this class. function jlua . Class : extend ( name : any ) -> nil Parameter Type Description Default name * any","title":"extend()"},{"location":"api/object/#is_class_of","text":"Signature Return true if the given object is an instance of this class. function jlua . Class : is_class_of ( object : any ) -> nil Parameter Type Description Default object * any","title":"is_class_of()"},{"location":"api/object/#wrap","text":"Signature Create an instance of this class by setting it's metatable. function jlua . Class : wrap ( object : any ) -> nil Parameter Type Description Default object * any","title":"wrap()"},{"location":"api/object/#propertyguard","text":"","title":"PropertyGuard"},{"location":"api/object/#methods_1","text":"","title":"Methods"},{"location":"api/object/#__newindex_1","text":"Signature function PropertyGuard : __newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any","title":"__newindex()"},{"location":"api/object/#propertiesguard","text":"","title":"PropertiesGuard"},{"location":"api/object/#methods_2","text":"","title":"Methods"},{"location":"api/object/#__index_1","text":"Signature function PropertiesGuard : __index ( key : any ) -> nil Parameter Type Description Default key * any","title":"__index()"},{"location":"api/object/#__newindex_2","text":"Signature function PropertiesGuard : __newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any","title":"__newindex()"},{"location":"api/path/","text":"unknown \u00b6 Classes \u00b6 Path \u00b6 Methods \u00b6 init() \u00b6 Signature Initialize a path function Path : init ( source : any ) -> nil Parameter Type Description Default source * any __div() \u00b6 Signature Concatenate two paths. function Path : __div ( right : any ) -> nil Parameter Type Description Default right * any __tostring() \u00b6 Signature Returns the string representation of this path function Path : __tostring () -> nil Parameter Type Description Default open() \u00b6 Signature Open the file this path points to. function Path : open ( mode : any ) -> nil Parameter Type Description Default mode * any relative_to() \u00b6 Signature Get the current path relative to given path. function Path : relative_to ( right : any ) -> nil Parameter Type Description Default right * any is_child_of() \u00b6 Signature Return true if this path is a child of the given path function Path : is_child_of ( parent : any ) -> nil Parameter Type Description Default parent * any","title":"unknown"},{"location":"api/path/#unknown","text":"","title":"unknown"},{"location":"api/path/#classes","text":"","title":"Classes"},{"location":"api/path/#path","text":"","title":"Path"},{"location":"api/path/#methods","text":"","title":"Methods"},{"location":"api/path/#init","text":"Signature Initialize a path function Path : init ( source : any ) -> nil Parameter Type Description Default source * any","title":"init()"},{"location":"api/path/#__div","text":"Signature Concatenate two paths. function Path : __div ( right : any ) -> nil Parameter Type Description Default right * any","title":"__div()"},{"location":"api/path/#__tostring","text":"Signature Returns the string representation of this path function Path : __tostring () -> nil Parameter Type Description Default","title":"__tostring()"},{"location":"api/path/#open","text":"Signature Open the file this path points to. function Path : open ( mode : any ) -> nil Parameter Type Description Default mode * any","title":"open()"},{"location":"api/path/#relative_to","text":"Signature Get the current path relative to given path. function Path : relative_to ( right : any ) -> nil Parameter Type Description Default right * any","title":"relative_to()"},{"location":"api/path/#is_child_of","text":"Signature Return true if this path is a child of the given path function Path : is_child_of ( parent : any ) -> nil Parameter Type Description Default parent * any","title":"is_child_of()"},{"location":"api/string/","text":"jlua.string \u00b6 String utilities. This module contains various helpers related to string. The metatable of string isn't replaced, meaning all methods declared here have to be called explicitely. Methods \u00b6 format() \u00b6 Signature Extended string format. function format ( fmt : string , ...: any ) -> string Parameter Type Description Default fmt * string String format. ... * any Format arguments. Returns Description string Formatted string. Notes Replacement fields in the format string are delimited with braces {}. Each replacement field can contains either a name of a a keyword argument, the index of a positionnal arguments or nothing. Each time a replacement field with no name or index is provided, the next format argument is taken. Field format can be sepcified after a colon : in a replacement field. This format is passed to the lua format function, thus the format for C function printf applies. To escape braces, simply double them. Usage jlua . string . format ( \"{} is an {species} called {0}\" , \"Jean-Paul\" , { species = \"otter\" }) -- Jean-Paul is an otter called Jean-Paul format ( \"{} is {:.2f} years old\" , \"Jean-Paul\" , 24.2342 ) -- Jean-Paul is 24.23 years old format ( \"{name} is {age:.2f} years old\" , { name = \"Jean-Paul\" , age = 24.2342 }) -- Jean-Paul is 24.23 years old","title":"jlua.string"},{"location":"api/string/#jluastring","text":"String utilities. This module contains various helpers related to string. The metatable of string isn't replaced, meaning all methods declared here have to be called explicitely.","title":"jlua.string"},{"location":"api/string/#methods","text":"","title":"Methods"},{"location":"api/string/#format","text":"Signature Extended string format. function format ( fmt : string , ...: any ) -> string Parameter Type Description Default fmt * string String format. ... * any Format arguments. Returns Description string Formatted string. Notes Replacement fields in the format string are delimited with braces {}. Each replacement field can contains either a name of a a keyword argument, the index of a positionnal arguments or nothing. Each time a replacement field with no name or index is provided, the next format argument is taken. Field format can be sepcified after a colon : in a replacement field. This format is passed to the lua format function, thus the format for C function printf applies. To escape braces, simply double them. Usage jlua . string . format ( \"{} is an {species} called {0}\" , \"Jean-Paul\" , { species = \"otter\" }) -- Jean-Paul is an otter called Jean-Paul format ( \"{} is {:.2f} years old\" , \"Jean-Paul\" , 24.2342 ) -- Jean-Paul is 24.23 years old format ( \"{name} is {age:.2f} years old\" , { name = \"Jean-Paul\" , age = 24.2342 }) -- Jean-Paul is 24.23 years old","title":"format()"},{"location":"api/type/","text":"unknown \u00b6","title":"unknown"},{"location":"api/type/#unknown","text":"","title":"unknown"},{"location":"api/test/call/","text":"unknown \u00b6 Classes \u00b6 Call \u00b6 Methods \u00b6 init() \u00b6 Signature Initialize the call function Call : init (...: any ) -> nil Parameter Type Description Default ... * any __eq() \u00b6 Signature Check if this call matches the given one. function Call : __eq ( right : any ) -> nil Parameter Type Description Default right * any","title":"Test"},{"location":"api/test/call/#unknown","text":"","title":"unknown"},{"location":"api/test/call/#classes","text":"","title":"Classes"},{"location":"api/test/call/#call","text":"","title":"Call"},{"location":"api/test/call/#methods","text":"","title":"Methods"},{"location":"api/test/call/#init","text":"Signature Initialize the call function Call : init (...: any ) -> nil Parameter Type Description Default ... * any","title":"init()"},{"location":"api/test/call/#__eq","text":"Signature Check if this call matches the given one. function Call : __eq ( right : any ) -> nil Parameter Type Description Default right * any","title":"__eq()"},{"location":"api/test/mock/","text":"unknown \u00b6 Classes \u00b6 Mock \u00b6 Methods \u00b6 init() \u00b6 Signature Initialize the mock function Mock : init ( args : any ) -> nil Parameter Type Description Default args * any __call() \u00b6 Signature Call metamethod function Mock : __call (...: any ) -> nil Parameter Type Description Default ... * any __index() \u00b6 Signature Indexing metamethod function Mock : __index ( key : any ) -> nil Parameter Type Description Default key * any as_function() \u00b6 Signature Get a closure calling that mock. function Mock : as_function () -> nil Parameter Type Description Default reset() \u00b6 Signature Reset the call list for that mock function Mock : reset () -> nil Parameter Type Description Default","title":"unknown"},{"location":"api/test/mock/#unknown","text":"","title":"unknown"},{"location":"api/test/mock/#classes","text":"","title":"Classes"},{"location":"api/test/mock/#mock","text":"","title":"Mock"},{"location":"api/test/mock/#methods","text":"","title":"Methods"},{"location":"api/test/mock/#init","text":"Signature Initialize the mock function Mock : init ( args : any ) -> nil Parameter Type Description Default args * any","title":"init()"},{"location":"api/test/mock/#__call","text":"Signature Call metamethod function Mock : __call (...: any ) -> nil Parameter Type Description Default ... * any","title":"__call()"},{"location":"api/test/mock/#__index","text":"Signature Indexing metamethod function Mock : __index ( key : any ) -> nil Parameter Type Description Default key * any","title":"__index()"},{"location":"api/test/mock/#as_function","text":"Signature Get a closure calling that mock. function Mock : as_function () -> nil Parameter Type Description Default","title":"as_function()"},{"location":"api/test/mock/#reset","text":"Signature Reset the call list for that mock function Mock : reset () -> nil Parameter Type Description Default","title":"reset()"},{"location":"usage/_index/","text":"Usage \u00b6 Here is the documentation of the jean-lua API.","title":"Usage"},{"location":"usage/_index/#usage","text":"Here is the documentation of the jean-lua API.","title":"Usage"},{"location":"usage/functional/","text":"Functional \u00b6 Functional programming involves iterators and function objects.","title":"Functional"},{"location":"usage/functional/#functional","text":"Functional programming involves iterators and function objects.","title":"Functional"},{"location":"usage/object/","text":"Object \u00b6 The jlua.object module contains definition of an Object class, that can be extended to create new classes. It supports single inheritance, methods, properties with getters and setters and metamethod overriding, including __index and __newindex. Defining a new class \u00b6 A new class can be created by extending from another one. Derived class will inherit the methods, metamethods and properties of it's parent. If your class has no base class, extend the Object class. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () local SpaceOtter = Otter : extend () Constructors \u00b6 Objects are constructed by calling the class. You can give arguments to the constructor, they will be forwarded to the init method of the class, if it's defined. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init ( name ) print ( \"My name is \" .. name ) end local peter = Otter ( \"Peter\" ) -- -> \"My name is Peter\" Warning If you override a base class init method, don't forget to call the parent init method by calling self:super(\"init\", ...) . Methods \u00b6 Method Definition \u00b6 Methods can be defined either by adding them on the class metatable before calling the extend() method, or afterwards, by defining them on the class, like you do on regular lua tables : local Object = require ( \"jlua.object\" ) local Otter = Object : extend ({ name = function () return \"Peter\" end }) function Otter : last_name () return \"Otterson\" end Warning Defining twice the same method will assert. This is done to prevent unwanted method overwrites. If you really need to overwrite a method, you can do it by using rawset like this: rawset(Otter._definition._metatable, \"last_name\", function() [...] end) Calling Parent Methods \u00b6 To call a parent method in a child class, use the super() method defined on classes instances, with the method name as the first argument, arguments to forward to the parent method next : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : throw ( distance ) return \"throwing otter at \" .. distance .. \"m\" end local SpaceOtter = Otter : extend () local SpaceOtter : throw ( distance ) self : super ( \"throw\" , distance + 100 ) end local peter = SpaceOtter () peter : throw_at ( 33 ) -- -> Throwing otter at 133m Properties \u00b6 Properties are defined using the \"properties\" field of classes, accessing the wanted property on it and defining a get or a set method : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init () self . _age = 10 end function Otter . properties . age : get () -- Notice the colon before get() return self . _age end function Otter . properties . age : set ( value ) -- Notice the colon before set() self . _age = value end local peter = Otter () print ( peter . age ) -- 10 peter . age = 40 print ( peter . age ) -- 40 You can define properties with only a getter, or only a setter. You can define a property with no getter nor setter, but in this case it will only be defined in your head and will have no effect on the running program. Warning Setting a property with no setter defined, or getting a property with no getter will raise an error at runtime. There is no default behavior for getters / setters once one of them is defined. Warning Redefining a getter or a setter that was already defined on a property will raise an error. Same as for methods, this was made to prevent erroneous method overwriting.","title":"Object"},{"location":"usage/object/#object","text":"The jlua.object module contains definition of an Object class, that can be extended to create new classes. It supports single inheritance, methods, properties with getters and setters and metamethod overriding, including __index and __newindex.","title":"Object"},{"location":"usage/object/#defining-a-new-class","text":"A new class can be created by extending from another one. Derived class will inherit the methods, metamethods and properties of it's parent. If your class has no base class, extend the Object class. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () local SpaceOtter = Otter : extend ()","title":"Defining a new class"},{"location":"usage/object/#constructors","text":"Objects are constructed by calling the class. You can give arguments to the constructor, they will be forwarded to the init method of the class, if it's defined. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init ( name ) print ( \"My name is \" .. name ) end local peter = Otter ( \"Peter\" ) -- -> \"My name is Peter\" Warning If you override a base class init method, don't forget to call the parent init method by calling self:super(\"init\", ...) .","title":"Constructors"},{"location":"usage/object/#methods","text":"","title":"Methods"},{"location":"usage/object/#method-definition","text":"Methods can be defined either by adding them on the class metatable before calling the extend() method, or afterwards, by defining them on the class, like you do on regular lua tables : local Object = require ( \"jlua.object\" ) local Otter = Object : extend ({ name = function () return \"Peter\" end }) function Otter : last_name () return \"Otterson\" end Warning Defining twice the same method will assert. This is done to prevent unwanted method overwrites. If you really need to overwrite a method, you can do it by using rawset like this: rawset(Otter._definition._metatable, \"last_name\", function() [...] end)","title":"Method Definition"},{"location":"usage/object/#calling-parent-methods","text":"To call a parent method in a child class, use the super() method defined on classes instances, with the method name as the first argument, arguments to forward to the parent method next : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : throw ( distance ) return \"throwing otter at \" .. distance .. \"m\" end local SpaceOtter = Otter : extend () local SpaceOtter : throw ( distance ) self : super ( \"throw\" , distance + 100 ) end local peter = SpaceOtter () peter : throw_at ( 33 ) -- -> Throwing otter at 133m","title":"Calling Parent Methods"},{"location":"usage/object/#properties","text":"Properties are defined using the \"properties\" field of classes, accessing the wanted property on it and defining a get or a set method : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init () self . _age = 10 end function Otter . properties . age : get () -- Notice the colon before get() return self . _age end function Otter . properties . age : set ( value ) -- Notice the colon before set() self . _age = value end local peter = Otter () print ( peter . age ) -- 10 peter . age = 40 print ( peter . age ) -- 40 You can define properties with only a getter, or only a setter. You can define a property with no getter nor setter, but in this case it will only be defined in your head and will have no effect on the running program. Warning Setting a property with no setter defined, or getting a property with no getter will raise an error at runtime. There is no default behavior for getters / setters once one of them is defined. Warning Redefining a getter or a setter that was already defined on a property will raise an error. Same as for methods, this was made to prevent erroneous method overwriting.","title":"Properties"}]}