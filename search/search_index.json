{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Jean Lua \u00b6 An object-oriented lua toolkit library. For a complete reference of classes included in this library, check usage section","title":"Home"},{"location":"#welcome-to-jean-lua","text":"An object-oriented lua toolkit library. For a complete reference of classes included in this library, check usage section","title":"Welcome to Jean Lua"},{"location":"api/collection/","text":"unknown \u00b6","title":"Api Reference"},{"location":"api/collection/#unknown","text":"","title":"unknown"},{"location":"api/context/","text":"unknown \u00b6","title":"unknown"},{"location":"api/context/#unknown","text":"","title":"unknown"},{"location":"api/iterator/","text":"jlua.iterator \u00b6 Iterator, with map / filter functions and the like. Methods \u00b6 init() \u00b6 Signature function init ( iterator : fn ( any , any ? ): any ? , invariant : any ? , control : any ? ) -> Parameter Type Description Default iterator * fn(any,any?):any? The iterator function. invariant * any? Invariant state passed to the iterator. control * any? Initial control variable passed to the Description Can be initialized with a statefull iterator closure, or a stateless iterator iterator. In the later case, invariant and control are the states needed by the stateless iterator. For example, you can call : Iterator ( ipairs ({ \"some\" , \"list\" })) __call() \u00b6 Return the next element of the iterator. Signature function __call () -> Parameter Type Description Default all() \u00b6 Return true if all elements in the iterator matches the given predicate. Signature function all ( predicate : any ) -> Parameter Type Description Default predicate * any any() \u00b6 Return true if any element in the iterator matches the given predicate. Signature function any ( predicate : any ) -> Parameter Type Description Default predicate * any chain() \u00b6 Chain this iterator with elements of given iterable. Signature function chain ( iterable : any , ...: any ) -> Parameter Type Description Default iterable * any ... * any contains() \u00b6 Return true if any element in the iterator equals the given element Signature function contains ( item : any ) -> string Parameter Type Description Default item * any The item to check in the iterator Returns Description string True if an element equals the given item, false otherwise. count() \u00b6 Count number of element matching the given predicate. Signature function count ( predicate : any ) -> Parameter Type Description Default predicate * any filter() \u00b6 Return an iterator yielding elements matching the given predicate. Signature function filter ( predicate : any ) -> Parameter Type Description Default predicate * any first() \u00b6 Return the first element in the iterator matching the given predicate. Signature function first ( predicate : any ) -> Parameter Type Description Default predicate * any map() \u00b6 Return a new iterator yielding results of applying a function to all items. Signature function map ( mapper : any ) -> Parameter Type Description Default mapper * any flatten() \u00b6 Returns elements of the nested iterator of an iterator of iterators. Signature function flatten () -> Parameter Type Description Default reduce() \u00b6 Reduce the iterator. Signature function reduce ( func : any , init : any ) -> Parameter Type Description Default func * any init * any skip() \u00b6 Skip the first count elements of an iterator. Signature function skip ( count : any ) -> Parameter Type Description Default count * any take() \u00b6 Return the first elements of an iterator. Signature function take ( count : any ) -> Parameter Type Description Default count * any","title":"jlua.iterator"},{"location":"api/iterator/#jluaiterator","text":"Iterator, with map / filter functions and the like.","title":"jlua.iterator"},{"location":"api/iterator/#methods","text":"","title":"Methods"},{"location":"api/iterator/#init","text":"Signature function init ( iterator : fn ( any , any ? ): any ? , invariant : any ? , control : any ? ) -> Parameter Type Description Default iterator * fn(any,any?):any? The iterator function. invariant * any? Invariant state passed to the iterator. control * any? Initial control variable passed to the Description Can be initialized with a statefull iterator closure, or a stateless iterator iterator. In the later case, invariant and control are the states needed by the stateless iterator. For example, you can call : Iterator ( ipairs ({ \"some\" , \"list\" }))","title":"init()"},{"location":"api/iterator/#__call","text":"Return the next element of the iterator. Signature function __call () -> Parameter Type Description Default","title":"__call()"},{"location":"api/iterator/#all","text":"Return true if all elements in the iterator matches the given predicate. Signature function all ( predicate : any ) -> Parameter Type Description Default predicate * any","title":"all()"},{"location":"api/iterator/#any","text":"Return true if any element in the iterator matches the given predicate. Signature function any ( predicate : any ) -> Parameter Type Description Default predicate * any","title":"any()"},{"location":"api/iterator/#chain","text":"Chain this iterator with elements of given iterable. Signature function chain ( iterable : any , ...: any ) -> Parameter Type Description Default iterable * any ... * any","title":"chain()"},{"location":"api/iterator/#contains","text":"Return true if any element in the iterator equals the given element Signature function contains ( item : any ) -> string Parameter Type Description Default item * any The item to check in the iterator Returns Description string True if an element equals the given item, false otherwise.","title":"contains()"},{"location":"api/iterator/#count","text":"Count number of element matching the given predicate. Signature function count ( predicate : any ) -> Parameter Type Description Default predicate * any","title":"count()"},{"location":"api/iterator/#filter","text":"Return an iterator yielding elements matching the given predicate. Signature function filter ( predicate : any ) -> Parameter Type Description Default predicate * any","title":"filter()"},{"location":"api/iterator/#first","text":"Return the first element in the iterator matching the given predicate. Signature function first ( predicate : any ) -> Parameter Type Description Default predicate * any","title":"first()"},{"location":"api/iterator/#map","text":"Return a new iterator yielding results of applying a function to all items. Signature function map ( mapper : any ) -> Parameter Type Description Default mapper * any","title":"map()"},{"location":"api/iterator/#flatten","text":"Returns elements of the nested iterator of an iterator of iterators. Signature function flatten () -> Parameter Type Description Default","title":"flatten()"},{"location":"api/iterator/#reduce","text":"Reduce the iterator. Signature function reduce ( func : any , init : any ) -> Parameter Type Description Default func * any init * any","title":"reduce()"},{"location":"api/iterator/#skip","text":"Skip the first count elements of an iterator. Signature function skip ( count : any ) -> Parameter Type Description Default count * any","title":"skip()"},{"location":"api/iterator/#take","text":"Return the first elements of an iterator. Signature function take ( count : any ) -> Parameter Type Description Default count * any","title":"take()"},{"location":"api/list/","text":"jlua.List \u00b6 A list of items, with random access.","title":"jlua.List"},{"location":"api/list/#jlualist","text":"A list of items, with random access.","title":"jlua.List"},{"location":"api/map/","text":"unknown \u00b6","title":"unknown"},{"location":"api/map/#unknown","text":"","title":"unknown"},{"location":"api/object/","text":"unknown \u00b6","title":"unknown"},{"location":"api/object/#unknown","text":"","title":"unknown"},{"location":"api/path/","text":"unknown \u00b6","title":"unknown"},{"location":"api/path/#unknown","text":"","title":"unknown"},{"location":"api/string/","text":"jlua.string \u00b6 String utilities. This module contains various helpers related to string. The metatable of string isn't replaced, meaning all methods declared here have to be called explicitely. Methods \u00b6 format() \u00b6 Extended string format. Signature function format ( fmt : string , ...: any ) -> string Parameter Type Description Default fmt * string String format. ... * any Format arguments. Returns Description string Formatted string. Description Replacement fields in the format string are delimited with braces {}. Each replacement field can contains either a name of a a keyword argument, the index of a positionnal arguments or nothing. Each time a replacement field with no name or index is provided, the next format argument is taken. Field format can be sepcified after a colon : in a replacement field. This format is passed to the lua format function, thus the format for C function printf applies. To escape braces, simply double them. Usage format ( \"{} is an {species} called {0}\" , \"Jean-Paul\" , { species = \"otter\" }) -- Jean-Paul is an otter called Jean-Paul format ( \"{} is {:.2f} years old\" , \"Jean-Paul\" , 24.2342 ) -- Jean-Paul is 24.23 years old format ( \"{name} is {age:.2f} years old\" , { name = \"Jean-Paul\" , age = 24.2342 }) -- Jean-Paul is 24.23 years old","title":"jlua.string"},{"location":"api/string/#jluastring","text":"String utilities. This module contains various helpers related to string. The metatable of string isn't replaced, meaning all methods declared here have to be called explicitely.","title":"jlua.string"},{"location":"api/string/#methods","text":"","title":"Methods"},{"location":"api/string/#format","text":"Extended string format. Signature function format ( fmt : string , ...: any ) -> string Parameter Type Description Default fmt * string String format. ... * any Format arguments. Returns Description string Formatted string. Description Replacement fields in the format string are delimited with braces {}. Each replacement field can contains either a name of a a keyword argument, the index of a positionnal arguments or nothing. Each time a replacement field with no name or index is provided, the next format argument is taken. Field format can be sepcified after a colon : in a replacement field. This format is passed to the lua format function, thus the format for C function printf applies. To escape braces, simply double them. Usage format ( \"{} is an {species} called {0}\" , \"Jean-Paul\" , { species = \"otter\" }) -- Jean-Paul is an otter called Jean-Paul format ( \"{} is {:.2f} years old\" , \"Jean-Paul\" , 24.2342 ) -- Jean-Paul is 24.23 years old format ( \"{name} is {age:.2f} years old\" , { name = \"Jean-Paul\" , age = 24.2342 }) -- Jean-Paul is 24.23 years old","title":"format()"},{"location":"api/type/","text":"unknown \u00b6","title":"unknown"},{"location":"api/type/#unknown","text":"","title":"unknown"},{"location":"api/test/call/","text":"unknown \u00b6","title":"Test"},{"location":"api/test/call/#unknown","text":"","title":"unknown"},{"location":"api/test/mock/","text":"unknown \u00b6","title":"unknown"},{"location":"api/test/mock/#unknown","text":"","title":"unknown"},{"location":"usage/_index/","text":"Usage \u00b6 Here is the documentation of the jean-lua API.","title":"Usage"},{"location":"usage/_index/#usage","text":"Here is the documentation of the jean-lua API.","title":"Usage"},{"location":"usage/functional/","text":"Functional \u00b6 Functional programming involves iterators and function objects.","title":"Functional"},{"location":"usage/functional/#functional","text":"Functional programming involves iterators and function objects.","title":"Functional"},{"location":"usage/object/","text":"Object \u00b6 The jlua.object module contains definition of an Object class, that can be extended to create new classes. It supports single inheritance, methods, properties with getters and setters and metamethod overriding, including __index and __newindex. Defining a new class \u00b6 A new class can be created by extending from another one. Derived class will inherit the methods, metamethods and properties of it's parent. If your class has no base class, extend the Object class. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () local SpaceOtter = Otter : extend () Constructors \u00b6 Objects are constructed by calling the class. You can give arguments to the constructor, they will be forwarded to the init method of the class, if it's defined. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init ( name ) print ( \"My name is \" .. name ) end local peter = Otter ( \"Peter\" ) -- -> \"My name is Peter\" Warning If you override a base class init method, don't forget to call the parent init method by calling self:super(\"init\", ...) . Methods \u00b6 Method Definition \u00b6 Methods can be defined either by adding them on the class metatable before calling the extend() method, or afterwards, by defining them on the class, like you do on regular lua tables : local Object = require ( \"jlua.object\" ) local Otter = Object : extend ({ name = function () return \"Peter\" end }) function Otter : last_name () return \"Otterson\" end Warning Defining twice the same method will assert. This is done to prevent unwanted method overwrites. If you really need to overwrite a method, you can do it by using rawset like this: rawset(Otter._definition._metatable, \"last_name\", function() [...] end) Calling Parent Methods \u00b6 To call a parent method in a child class, use the super() method defined on classes instances, with the method name as the first argument, arguments to forward to the parent method next : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : throw ( distance ) return \"throwing otter at \" .. distance .. \"m\" end local SpaceOtter = Otter : extend () local SpaceOtter : throw ( distance ) self : super ( \"throw\" , distance + 100 ) end local peter = SpaceOtter () peter : throw_at ( 33 ) -- -> Throwing otter at 133m Properties \u00b6 Properties are defined using the \"properties\" field of classes, accessing the wanted property on it and defining a get or a set method : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init () self . _age = 10 end function Otter . properties . age : get () -- Notice the colon before get() return self . _age end function Otter . properties . age : set ( value ) -- Notice the colon before set() self . _age = value end local peter = Otter () print ( peter . age ) -- 10 peter . age = 40 print ( peter . age ) -- 40 You can define properties with only a getter, or only a setter. You can define a property with no getter nor setter, but in this case it will only be defined in your head and will have no effect on the running program. Warning Setting a property with no setter defined, or getting a property with no getter will raise an error at runtime. There is no default behavior for getters / setters once one of them is defined. Warning Redefining a getter or a setter that was already defined on a property will raise an error. Same as for methods, this was made to prevent erroneous method overwriting.","title":"Object"},{"location":"usage/object/#object","text":"The jlua.object module contains definition of an Object class, that can be extended to create new classes. It supports single inheritance, methods, properties with getters and setters and metamethod overriding, including __index and __newindex.","title":"Object"},{"location":"usage/object/#defining-a-new-class","text":"A new class can be created by extending from another one. Derived class will inherit the methods, metamethods and properties of it's parent. If your class has no base class, extend the Object class. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () local SpaceOtter = Otter : extend ()","title":"Defining a new class"},{"location":"usage/object/#constructors","text":"Objects are constructed by calling the class. You can give arguments to the constructor, they will be forwarded to the init method of the class, if it's defined. local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init ( name ) print ( \"My name is \" .. name ) end local peter = Otter ( \"Peter\" ) -- -> \"My name is Peter\" Warning If you override a base class init method, don't forget to call the parent init method by calling self:super(\"init\", ...) .","title":"Constructors"},{"location":"usage/object/#methods","text":"","title":"Methods"},{"location":"usage/object/#method-definition","text":"Methods can be defined either by adding them on the class metatable before calling the extend() method, or afterwards, by defining them on the class, like you do on regular lua tables : local Object = require ( \"jlua.object\" ) local Otter = Object : extend ({ name = function () return \"Peter\" end }) function Otter : last_name () return \"Otterson\" end Warning Defining twice the same method will assert. This is done to prevent unwanted method overwrites. If you really need to overwrite a method, you can do it by using rawset like this: rawset(Otter._definition._metatable, \"last_name\", function() [...] end)","title":"Method Definition"},{"location":"usage/object/#calling-parent-methods","text":"To call a parent method in a child class, use the super() method defined on classes instances, with the method name as the first argument, arguments to forward to the parent method next : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : throw ( distance ) return \"throwing otter at \" .. distance .. \"m\" end local SpaceOtter = Otter : extend () local SpaceOtter : throw ( distance ) self : super ( \"throw\" , distance + 100 ) end local peter = SpaceOtter () peter : throw_at ( 33 ) -- -> Throwing otter at 133m","title":"Calling Parent Methods"},{"location":"usage/object/#properties","text":"Properties are defined using the \"properties\" field of classes, accessing the wanted property on it and defining a get or a set method : local Object = require ( \"jlua.object\" ) local Otter = Object : extend () function Otter : init () self . _age = 10 end function Otter . properties . age : get () -- Notice the colon before get() return self . _age end function Otter . properties . age : set ( value ) -- Notice the colon before set() self . _age = value end local peter = Otter () print ( peter . age ) -- 10 peter . age = 40 print ( peter . age ) -- 40 You can define properties with only a getter, or only a setter. You can define a property with no getter nor setter, but in this case it will only be defined in your head and will have no effect on the running program. Warning Setting a property with no setter defined, or getting a property with no getter will raise an error at runtime. There is no default behavior for getters / setters once one of them is defined. Warning Redefining a getter or a setter that was already defined on a property will raise an error. Same as for methods, this was made to prevent erroneous method overwriting.","title":"Properties"}]}